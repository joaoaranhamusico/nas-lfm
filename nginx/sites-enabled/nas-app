# File: /etc/nginx/sites-available/nas-app
# SAFE-PROD-LITE v1.1.7a — APIs sempre JSON (429/50x/…); limites generosos por sessão
# Author: João Aranha
# Last Modified: 2025-11-05

# HTTP -> HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name nasutilities.top www.nasutilities.top;
    return 301 https://$host$request_uri;
}

# HTTPS (HTTP/2 DESLIGADO por hardening Fase 1)
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name nasutilities.top www.nasutilities.top;

    # TLS (Certbot standard)
    ssl_certificate     /etc/letsencrypt/live/nasutilities.top/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/nasutilities.top/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Helmet-friendly security headers
    include /etc/nginx/conf.d/security-headers.conf;

    # Limite de conexões por IP — amplo (anti-hoarding sem afetar UX)
    limit_conn conn_ip 100;

    access_log /var/log/nginx/nas-app.access.log main_ext;

    # Static root (fallbacks)
    root /home/aranha/nas-app/www;
    index index.html;

    # Upstream (HTTP/1.1 keep-alive já vem do kernel; upstream simples é suficiente)
    set $upstream "http://127.0.0.1:8888";

    # Proxy defaults
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # Se você tiver o 'map $http_upgrade $connection_upgrade' no nginx.conf, ótimo.
    # Se não tiver, esta variável ficará vazia e apenas degrade para conexões normais.
    proxy_set_header Upgrade    $http_upgrade;
    proxy_set_header Connection $connection_upgrade;

    proxy_connect_timeout 10s;
    proxy_send_timeout    300s;
    proxy_read_timeout    300s;
    send_timeout          300s;

    proxy_buffering off;
    proxy_request_buffering off;
    proxy_max_temp_file_size 0;

    # --- FALLBACKS ESTÁTICOS (online mesmo se Node cair) ---
    location = /bonuspointstracker       { try_files /nasbonustracker.html      =404; access_log off; }
    location = /nasbonustracker-help     { try_files /nasbonustracker-help.html =404; access_log off; }

    # --- HEALTH/WEBHOOKS (sem limite; manter JSON do backend) ---
    location = /health {
        proxy_intercept_errors off;   # deixe o backend responder
        proxy_pass $upstream;
    }

    location ^~ /webhook/discord {
        proxy_intercept_errors off;   # idem
        proxy_pass $upstream;
    }

    # --- AUTH (moderado por IP; sempre JSON em erro do Nginx) ---
    location ^~ /auth {
        limit_req zone=req_auth burst=60;      # fila curta em pico
        proxy_intercept_errors on;             # permitir handler JSON
        error_page 400 401 403 404 405 409 413 415 429 500 502 503 504 = @api_json_error;
        proxy_pass $upstream;
    }

    # --- AUTOSUBMIT (muito alto por sessão; sempre JSON em erro do Nginx) ---
    location ^~ /autosubmit {
        limit_req zone=req_autosubmit burst=200 nodelay;
        proxy_intercept_errors on;
        error_page 400 401 403 404 405 409 413 415 429 500 502 503 504 = @api_json_error;
        proxy_pass $upstream;
    }

    # --- SUBMIT (alto por sessão; sempre JSON em erro do Nginx) ---
    location ^~ /submit {
        limit_req zone=req_submit burst=120 nodelay;
        proxy_intercept_errors on;
        error_page 400 401 403 404 405 409 413 415 429 500 502 503 504 = @api_json_error;
        proxy_pass $upstream;
    }

    # --- LAST.FM MODULE (isolated sidecar on port 3001) ---
    location ^~ /lfm/ {
        proxy_intercept_errors on;             # keep JSON error handler for /lfm APIs
        error_page 400 401 403 404 405 409 413 415 429 500 502 503 504 = @api_json_error;
        proxy_pass http://127.0.0.1:3001;
    }
	# --- LAST.FM LEGACY UI (blueprint do app antigo) ---
	# Expondo o front legado servido pelo lfmServer.js em /legacy/*
	# Acesso externo: https://nasutilities.top/lfm-ui/
	location ^~ /lfm-ui/ {
    proxy_pass http://127.0.0.1:3001/legacy/;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
	}

    # --- ASSETS: bypass limiter + cache curto ---
    location ~* \.(?:css|js|png|jpg|jpeg|gif|svg|ico|webp|ttf|woff2?)$ {
        expires 15m;
        access_log off;
        try_files $uri @app;
    }

    # --- APP (rotas de navegação) ---
    location / {
        try_files $uri $uri.html @app;
    }

    # Upstream handler (padrão)
    location @app {
        proxy_pass $upstream;
        proxy_set_header Cookie $http_cookie;   # mantém sessão
        proxy_pass_header Set-Cookie;
    }

    # ---------- HANDLER ÚNICO: ERROS DE API EM JSON ----------
    # Sem interpolação de variáveis para evitar "$" parsing errors.
    location @api_json_error {
        internal;
        default_type application/json;

        # 429: rate limit
        if ($status = 429) {
            return 429 '{"error":"rate_limited","message":"Too Many Requests","status":429}';
        }

        # 5xx: upstream indisponível
        if ($status ~ ^5) {
            return 502 '{"error":"upstream_error","message":"Upstream temporarily unavailable","status":502}';
        }

        # Demais 4xx: requisição inválida/negada
        return 400 '{"error":"request_error","message":"Request could not be processed","status":400}';
    }

    # HTML friendly error pages só para navegação (não APIs):
    error_page 502 503 504 /50x.html;
    location = /50x.html { internal; root /usr/share/nginx/html; }
}
